<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>FP in Scala - Chapters 7 &amp; 8</title>

        <meta name="author" content="Matt Newman">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            # FP in Scala

                            ### Chapters 7 & 8

                            Purely functional parallelism & Property-based testing
                        </script>
                    </section>

                    <section>
                        <h2>Prelude</h2>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ### Part 1: Fundamentals

                            - What is functional programming?
                            - Getting started with FP in Scala
                            - Functional data structures
                            - Handling errors without exceptions
                            - Strictness and laziness
                            - Purely functional state
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Part 2: Functional design and combinator libraries

                            - Purely functional parallelism
                            - Property-based testing
                            - Parser combinators

                            > These chapters should be like peering over the shoulder of
                            > someone as they think through possible designs.

                            Note:
                            These chapters look at the impact the fundamentals in Part 1 have
                            on library design, by way of three examples
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Purely functional parallelism</h1>
                        <h3>(Chapter 7)</h3>
                    </section>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Why purely functional parallelism?

                        * Modern computers have multiple cores/multiple CPUs
                        * Shared mutable memory remains hard
                            * Race conditions
                            * Deadlocks
                            * Testing is difficult
                        * We want to be able to use the substitution model and reason about
                          our code, *by separating the concern of
                          describing a computation from actually running it.*
                    </script>
                </section>

                <section>
                    <section>
                        <h2>A motivating example</h2>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Summing a list of integers:

                            ```scala
                            def sum(ints: Seq[Int]): Int =
                                ints.foldLeft(0)((a,b) => a + b)
                            ```
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Same operation, using a divide-and-conquer algorithm:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Int =
                                if (ints.size <= 1)
                                    ints.headOption getOrElse 0
                                else {
                                    val (l,r) = ints.splitAt(ints.length / 2)
                                    sum(l) + sum(r)
                                }
                            ```

                            (this implementation can be parallelised)

                            Note:
                            Summing integers is probably so fast that the overhead of parallelisation is
                            probably greater than the improvement from running in parallel.

                            However, we don't care about the operation - we want to build a simple
                            and composable set of core data types and functions for parallelism.
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Choosing data types and functions</h2>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### An initial data type for parallel computations

                            First, a container type for our results:

                            ```scala
                            Par[A]
                            ```

                            Second, a function to create a 'unit' of parallelism:

                            ```scala
                            def unit[A](a: => A): Par[A]
                            ```

                            Third, a method to extract the value from a parallel computation:

                            ```scala
                            def get[A](a: Par[A]): A
                            ```

                            Note:
                            For now, we don't need to worry about what other functions we require,
                            or internal representation of `Par`.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Let's change our `sum` example to use this API:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Int =
                                if (ints.size <= 1)
                                    ints headOption getOrElse 0
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    val sumL: Par[Int] = Par.unit(sum(l))
                                    val sumR: Par[Int] = Par.unit(sum(r))
                                    Par.get(sumL) + Par.get(sumR)
                                }
                            ```

                            Should `unit` start evaluating its argument immediately, or wait?

                            Note:
                            - In this example, `unit` must start evaluating immediately to get any parallelism
                                - Because if we wait until `get` is called, we will spawn the computation
                                  and wait for it immediately, before starting the second computation
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Is

                            ```scala
                            val sumL: Par[Int] = Par.unit(sum(l))
                            val sumR: Par[Int] = Par.unit(sum(r))
                            Par.get(sumL) + Par.get(sumR)
                            ```

                            equivalent to

                            ```scala
                            Par.get(Par.unit(sum(l))) + Par.get(Par.unit(sum(r)))
                            ```

                            ?
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            If `unit` begins evaluating its argument concurrently, then
                            calling `get` arguably breaks _referential transparency_, as our
                            program is no longer parallel

                            ... and we've lost.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Referential transparency (a.k.a. the goal)

                            An expression `e` is referentially transparent if, for all programs
                            `p`, all occurrences of `e` in `p` can be replaced by the result of
                            evaluating `e` without affecting the meaning of `p`.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            It's becoming clear that we need to combine asynchronous computations without
                            waiting for them to finish...

                            Note:
                            We have:
                            - Conjoured up a simple example
                            - Explored it to uncover a design choice
                            - Experimented and learned something fundamental about our domain
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Combining parallel computations
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Explicit forking
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Choosing a representation
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Property based testing</h1>
                        <h3>(Chapter 8)</h3>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            # FIN
                            Talk and slides by [Matt Newman](http://mdjnewman.me) ([@mdjnewman](https://twitter.com/mdjnewman))

                            </br>

                            [Buy the book](https://www.manning.com/books/functional-programming-in-scala)
                            and look at the [exercises and source code](https://github.com/fpinscala/fpinscala)

                            Slides: http://mdjnewman.me/talk-fp-in-scala-7-8/

                            <small>Also, check out <a href="https://twitter.com/SICPQuotes">@SICPQuotes</a></small>
                        </script>
                    </section>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
