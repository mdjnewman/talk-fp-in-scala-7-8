<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>FP in Scala - Chapters 7 &amp; 8</title>

        <meta name="author" content="Matt Newman">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            # FP in Scala

                            ### Chapters 7 & 8

                            Purely functional parallelism & Property-based testing
                        </script>
                    </section>

                    <section>
                        <h2>Prelude</h2>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ### Part 1: Fundamentals

                            - What is functional programming?
                            - Getting started with FP in Scala
                            - Functional data structures
                            - Handling errors without exceptions
                            - Strictness and laziness
                            - Purely functional state
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Part 2: Functional design and combinator libraries

                            - Purely functional parallelism
                            - Property-based testing
                            - Parser combinators

                            > These chapters should be like peering over the shoulder of
                            > someone as they think through possible designs.

                            Note:
                            These chapters look at the impact the fundamentals in Part 1 have
                            on library design, by way of three examples
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Purely functional parallelism</h1>
                        <h3>(Chapter 7)</h3>
                    </section>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Why purely functional parallelism?

                        * Modern computers have multiple cores/multiple CPUs
                        * Shared mutable memory remains hard
                            * Race conditions
                            * Deadlocks
                            * Testing is difficult
                        * We want to be able to use the substitution model and reason about
                          our code, _by separating the concern of
                          describing a computation from actually running it_.
                    </script>
                </section>

                <section>
                    <section>
                        <h2>A motivating example</h2>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Summing a list of integers:

                            ```scala
                            def sum(ints: Seq[Int]): Int =
                                ints.foldLeft(0)((a,b) => a + b)
                            ```
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Same operation, using a divide-and-conquer algorithm:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Int =
                                if (ints.size <= 1)
                                    ints.headOption getOrElse 0
                                else {
                                    val (l,r) = ints.splitAt(ints.length / 2)
                                    sum(l) + sum(r)
                                }
                            ```

                            (this implementation can be parallelised)

                            Note:
                            Summing integers is probably so fast that the overhead of parallelisation is
                            probably greater than the improvement from running in parallel.

                            However, we don't care about the operation - we want to build a simple
                            and composable set of core data types and functions for parallelism.
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Choosing data types and functions</h2>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### An initial data type for parallel computations

                            First, a container type for our results:

                            ```scala
                            Par[A]
                            ```

                            Second, a function to create a 'unit' of parallelism:

                            ```scala
                            def unit[A](a: => A): Par[A]
                            ```

                            Third, a method to extract the value from a parallel computation:

                            ```scala
                            def get[A](a: Par[A]): A
                            ```

                            Note:
                            For now, we don't need to worry about what other functions we require,
                            or internal representation of `Par`.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Let's change our `sum` example to use this API:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Int =
                                if (ints.size <= 1)
                                    ints headOption getOrElse 0
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    val sumL: Par[Int] = Par.unit(sum(l))
                                    val sumR: Par[Int] = Par.unit(sum(r))
                                    Par.get(sumL) + Par.get(sumR)
                                }
                            ```

                            Should `unit` start evaluating its argument immediately, or wait?

                            Note:
                            - In this example, `unit` must start evaluating immediately to get any parallelism
                                - Because if we wait until `get` is called, we will spawn the computation
                                  and wait for it immediately, before starting the second computation
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Is

                            ```scala
                            val sumL: Par[Int] = Par.unit(sum(l))
                            val sumR: Par[Int] = Par.unit(sum(r))
                            Par.get(sumL) + Par.get(sumR)
                            ```

                            equivalent to

                            ```scala
                            Par.get(Par.unit(sum(l))) + Par.get(Par.unit(sum(r)))
                            ```

                            ?
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            If `unit` begins evaluating its argument concurrently, then
                            calling `get` arguably breaks _referential transparency_, as our
                            program is no longer parallel

                            ... and we've lost.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Referential transparency (a.k.a. the holy grail)

                            An expression `e` is referentially transparent if, for all programs
                            `p`, all occurrences of `e` in `p` can be replaced by the result of
                            evaluating `e` without affecting the meaning of `p`.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            It's becoming clear that we need to combine asynchronous computations without
                            waiting for them to finish...

                            Note:
                            We have:
                            - Conjoured up a simple example
                            - Explored it to uncover a design choice
                            - Experimented and learned something fundamental about our domain
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Combining parallel computations

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Par[Int] =
                                if (ints.size <= 1)
                                    Par.unit(ints.headOption getOrElse 0)
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    Par.map2(sum(l), sum(r))(_ + _)
                                }
                            ```

                            where `Par.map2` is defined as:

                            ```scala
                            def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C]
                            ```

                            Now, should `map2` take its arguments lazily?

                            Note:
                            If `map2` takes its arguments strictly, then the first argument will be
                            fully constructed before we even consider the second argument.

                            Seems we should make `map2` lazy and have it begin execution of both
                            sides in parallel.
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Explicit forking

                            Do we _always_ want to evaluate the two arguments to `map2` in parallel?

                            What about in this simple case?

                            ```scala
                            Par.map2(Par.unit(1), Par.unit(1))(_ + _)
                            ```

                            With out current API, there is no way for the caller to say whether
                            a computation should be forked onto a separate thread.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Let's introduce a new primitive for the caller to specify if a computation
                            needs to be forked onto a separate thread:

                            ```scala
                            def fork[A](a: => Par[A]): Par[A]
                            ```

                            Adding this to our `sum` example:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Par[Int] =
                                if (ints.length <= 1)
                                    Par.unit(ints.headOption getOrElse 0)
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    Par.map2(Par.fork(sum(l)), Par.fork(sum(r)))(_ + _)
                                }
                            ```

                            This solves the problem of instantiating our
                            parallel computations too strictly, but more fundamentally _it
                            puts the parallelism explicitly under programmer control_.

                            No arbitrary decision making here!
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Should `unit` be strict or lazy?

                            Thanks to `fork`, we can make it strict.

                            ```scala
                            def unit[A](a: A): Par[A]
                            def lazyUnit[A](a: => A): Par[A] = fork(unit(a))
                            ```

                            `lazyUnit` is a simple example of a <del>contrived</del> _derived_
                            combinator, as opposed to a _primitive_ combinator like `unit`.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            One more decision - should `fork` begin evaluating arguments immediately,
                            or wait until the computation is forced? (e.g. by a call to `get`)?

                            If `fork` is to start computation immediately, it must be doing so
                            using some globally accessible resource.

                            Alternatively, `fork` can just 'mark' an unevaluated `Par` for concurrent
                            evaluation.

                            Note:
                            (there is more to say on this if needed)
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            In this model, `Par` becomes more of a _description_ of a parallel
                            computation, rather than a _container_ that we could just `get` a
                            value from when required.

                            To make it clear that a `Par` is basically a program that can be run,
                            let's rename `get`:
                            ```scala
                            def run[A](a: Par[A]): A
                            ```
                            `Par` is now a pure data structure, and `run` has to have some means of
                            implementing the parallelism...
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Choosing a representation
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Let's review our updated API for `Par`:
                            ```scala
                            // Create a computation that returns immediately
                            def unit[A](a: A): Par[A]

                            // Combine the results of two parallel computations
                            def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C]

                            // Mark a computation to be executed for concurrent evaluation
                            def fork[A](a: => Par[A]): Par[A]

                            // Wraps the expression a for concurrent evaluation
                            def lazyUnit[A](a: => A): Par[A] = fork(unit(a))

                            // Fully evaluate a given Par, spawing parallel computations
                            // as requested by fork
                            def run[A](a: Par[A]): A
                            ```

                            Note:
                            Currently we're just assuming that `run` has some way of implementing
                            parallelism.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Can we use the java.util.ExecutorService?
                            ```scala
                            class ExecutorService {
                                def submit[A](a: Callable[A]): Future[A]
                            }

                            trait Callable[A] { def call: A } // just a lazy A

                            trait Future[A] {
                                def get: A
                                def get(timeout: Long, unit: TimeUnit): A
                                def cancel(evenIfRunning: Boolean): Boolean
                                def isDone: Boolean
                                def isCancelled: Boolean
                            }
                            ```

                            Can `run` implement parallelism using an `ExecutorService`?

                            Note:
                            This is the Java API transcribed to Scala.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            For now, let's assume so:
                            ```scala
                            def run[A](s: ExecutorService)(a: Par[A]): A
                            ```
                            Now, if we define `Par[A]` to be:
                            ```scala
                            type Par[A] = ExecutorService => Future[A]
                            ```
                            Then `run` becomes trivial to implement:
                            ```scala
                            def run[A](s: ExecutorService)(a: Par[A]): Future[A] = a(s)
                            ```

                            Note:
                            By having `Par[A]` defined this way, we give the caller the ability to
                            choose how long to wait for a computation or whether to cancel it etc.

                            `Par` is a function that needs an `ExecutorService`, so the creation
                            of the `Future` doesn't happen until it's provided.
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Refining our API
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Before we move on, let's look at what is possible with the API we have so far.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                            object Par {
                              type Par[A] = ExecutorService => Future[A]

                              def run[A](s: ExecutorService)(a: Par[A]): Future[A] = a(s)

                              def unit[A](a: A): Par[A] = (es: ExecutorService) => UnitFuture(a)

                              // This implementation of `map2` does _not_ respect timeouts
                              def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C] =
                                (es: ExecutorService) => {
                                  val af = a(es)
                                  val bf = b(es)
                                  UnitFuture(f(af.get, bf.get))
                                }

                              // ...
                            ```

                            Note:
                            - `UnitFuture` just wraps a constant value
                            - `map2` doesn't evaluate `f` in a separate logical thread, wrap it
                              in fork if you want that
                            - To support timeouts in `map2`, we'd need a new implementation of `Future`
                              that keeps track of the amount of time spend evaluating `af`
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                              def map[A,B](pa: Par[A])(f: A => B): Par[B] =
                                map2(pa, unit(()))((a,_) => f(a))

                              def sortPar(parList: Par[List[Int]]) = map(parList)(_.sorted)

                              def fork[A](a: => Par[A]): Par[A] =
                                es => es.submit(new Callable[A] {
                                  def call = a(es).get
                                })

                              def equal[A](e: ExecutorService)(p: Par[A], p2: Par[A]): Boolean =
                                p(e).get == p2(e).get

                              // ...
                            ```

                            Note:
                            - `map` can lift any function with type `A => B` to operate over a `Par`
                            - This implementation of `fork` is simple, but has some problems
                                - The callable we pass to `es.submit` will block waiting for the
                                  `get` to complete - so we're using two threads
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                            def sequence[A](ps: List[Par[A]]): Par[List[A]] =
                              sys.error("Do your homework!")

                            def parMap[A,B](ps: List[A])(f: A => B): Par[List[B]] = fork {
                              val fbs: List[Par[B]] = ps.map(asyncF(f))
                              sequence(fbs)
                            }
                            ```

                            Note:
                            We're wrapping the body of `parMap` in a `fork` - it will always return
                            immediately, and when we call `run` later it will spawn a computation
                            which itself spawns `N` computations
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## The algebra of an API
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Property based testing</h1>
                        <h3>(Chapter 8)</h3>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            # FIN
                            Talk and slides by [Matt Newman](http://mdjnewman.me) ([@mdjnewman](https://twitter.com/mdjnewman))

                            </br>

                            [Buy the book](https://www.manning.com/books/functional-programming-in-scala)
                            and look at the [exercises and source code](https://github.com/fpinscala/fpinscala)

                            Slides: http://mdjnewman.me/talk-fp-in-scala-7-8/

                            <small>Also, check out <a href="https://twitter.com/SICPQuotes">@SICPQuotes</a></small>
                        </script>
                    </section>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
