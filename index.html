<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>FP in Scala - Chapters 7 &amp; 8</title>

        <meta name="author" content="Matt Newman">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            # FP in Scala

                            ### Chapters 7 & 8

                            Purely functional parallelism & Property-based testing

                            <small>Created by [Matt Newman](http://mdjnewman.me/) for the April 2016 [BFPG](http://www.meetup.com/Brisbane-Functional-Programming-Group/) meetup</small>
                        </script>
                    </section>

                    <section>
                        <h2>Prelude</h2>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ### Part 1: Fundamentals

                            - What is functional programming?
                            - Getting started with FP in Scala
                            - Functional data structures
                            - Handling errors without exceptions
                            - Strictness and laziness
                            - Purely functional state
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Part 2: Functional design and combinator libraries

                            - Purely functional parallelism
                            - Property-based testing
                            - Parser combinators

                            > These chapters should be like peering over the shoulder of
                            > someone as they think through possible designs.

                            Note:
                            These chapters look at the impact the fundamentals in Part 1 have
                            on library design, by way of three examples
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Purely functional parallelism</h1>
                        <h3>(Chapter 7)</h3>
                    </section>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Why purely functional parallelism?

                        * Modern computers have multiple cores/multiple CPUs
                        * Shared mutable memory remains hard
                            * Race conditions
                            * Deadlocks
                            * Testing is difficult
                        * We want to be able to use the substitution model and reason about
                          our code, _by separating the concern of
                          describing a computation from actually running it_.
                    </script>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## A motivating example

                            Note:
                            To start with, let's look at an example that we can refer back to
                            in order to make things a little more concrete.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Summing a list of integers:

                            ```scala
                            def sum(ints: Seq[Int]): Int =
                                ints.foldLeft(0)((a,b) => a + b)
                            ```
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Same operation, using a divide-and-conquer algorithm:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Int =
                                if (ints.size <= 1)
                                    ints.headOption getOrElse 0
                                else {
                                    val (l,r) = ints.splitAt(ints.length / 2)
                                    sum(l) + sum(r)
                                }
                            ```

                            (this implementation can be parallelised)

                            Note:
                            Summing integers is probably so fast that the overhead of parallelisation is
                            probably greater than the improvement from running in parallel.

                            However, we don't care about the operation - we want to build a simple
                            and composable set of core data types and functions for parallelism.
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Choosing data types and functions</h2>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### An initial data type for parallel computations

                            First, a container type for our results:

                            ```scala
                            Par[A]
                            ```

                            Second, a function to create a 'unit' of parallelism:

                            ```scala
                            def unit[A](a: => A): Par[A]
                            ```

                            Third, a method to extract the value from a parallel computation:

                            ```scala
                            def get[A](a: Par[A]): A
                            ```

                            Note:
                            For now, we don't need to worry about what other functions we require,
                            or internal representation of `Par`.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Let's change our `sum` example to use this API:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Int =
                                if (ints.size <= 1)
                                    ints headOption getOrElse 0
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    val sumL: Par[Int] = Par.unit(sum(l))
                                    val sumR: Par[Int] = Par.unit(sum(r))
                                    Par.get(sumL) + Par.get(sumR)
                                }
                            ```

                            Should `unit` start evaluating its argument immediately, or wait?

                            Note:
                            - In this example, `unit` must start evaluating immediately to get any parallelism
                                - Because if we wait until `get` is called while evaluating the first argument
                                  to our `+` function, we will spawn the computation and wait for it
                                  immediately, before starting the second computation
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Is

                            ```scala
                            val sumL: Par[Int] = Par.unit(sum(l))
                            val sumR: Par[Int] = Par.unit(sum(r))
                            Par.get(sumL) + Par.get(sumR)
                            ```

                            equivalent to

                            ```scala
                            Par.get(Par.unit(sum(l))) + Par.get(Par.unit(sum(r)))
                            ```

                            ?
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            If `unit` begins evaluating its argument concurrently, then
                            calling `get` arguably breaks _referential transparency_, as our
                            program is no longer parallel

                            ... and we've lost.
                        </script>
                    </section>
                    <!--
                    <section data-markdown>
                        <script type="text/template">
                            ### Referential transparency (a.k.a. the holy grail)

                            An expression `e` is referentially transparent if, for all programs
                            `p`, all occurrences of `e` in `p` can be replaced by the result of
                            evaluating `e` without affecting the meaning of `p`.
                        </script>
                    </section>
                    -->
                    <section data-markdown>
                        <script type="text/template">
                            It's becoming clear that we need to combine asynchronous computations without
                            waiting for them to finish...

                            Note:
                            So if `unit` doesn't start evaluation of a parallel computation immediately,
                            but we want to compute the sums of the two sublists in parallel, then we
                            need some way to combine two parallel computations to create a third.

                            We have:
                            - Conjoured up a simple example
                            - Explored it to uncover a design choice
                            - Experimented and learned something fundamental about our domain
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Combining parallel computations

                            Imagine a function `map2`, defined as:

                            ```scala
                            def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C]
                            ```

                            We can use this in our example:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Par[Int] =
                                if (ints.size <= 1)
                                    Par.unit(ints.headOption getOrElse 0)
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    Par.map2(sum(l), sum(r))(_ + _)
                                }
                            ```

                            Note:
                            So we're now no longer calling `unit` or `get` in our recursive case,
                            and `map2` is free to start evaluating both its arguments in parallel.
                        </script>
                    </section>
                    <!--
                    <section data-markdown>
                        <script type="text/template">
                            Now, should `map2` take its arguments lazily?

                            Note:
                            If `map2` takes its arguments strictly, then the first argument will be
                            fully constructed before we even consider the second argument.

                            Seems we should make `map2` lazy and have it begin execution of both
                            sides in parallel.
                        </script>
                    </section>
                    -->
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Explicit forking

                            Do we _always_ want to evaluate the two arguments to `map2` in parallel?

                            What about in this simple case?

                            ```scala
                            Par.map2(Par.unit(1), Par.unit(1))(_ + _)
                            ```

                            Note:
                            With our current API, there is no way for the caller to say whether
                            a computation should be forked onto a separate thread.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Introducing `fork`:
                            ```scala
                            def fork[A](a: => Par[A]): Par[A]
                            ```

                            Adding this to our `sum` example:

                            ```scala
                            def sum(ints: IndexedSeq[Int]): Par[Int] =
                                if (ints.length <= 1)
                                    Par.unit(ints.headOption getOrElse 0)
                                else {
                                    val (l,r) = ints.splitAt(ints.length/2)
                                    Par.map2(Par.fork(sum(l)), Par.fork(sum(r)))(_ + _)
                                }
                            ```

                            We've put the parallelism explicitly under programmer control, no arbitrary decision making here!

                            Note:
                            Let's introduce a new primitive for the caller to specify if a computation
                            needs to be forked onto a separate thread:

                            This solves the problem of instantiating our
                            parallel computations too strictly, but more fundamentally
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Should `unit` be strict or lazy?

                            Thanks to `fork`, we can make it strict.

                            ```scala
                            def unit[A](a: A): Par[A]
                            def lazyUnit[A](a: => A): Par[A] = fork(unit(a))
                            ```

                            `lazyUnit` is a simple example of a <del>contrived</del> _derived_
                            combinator, as opposed to a _primitive_ combinator like `unit`.

                            Note:
                            We haven't actually defined `unit` anywhere yet - we will get to that later
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            One more decision - should `fork` begin evaluating arguments immediately,
                            or wait until the computation is forced? (e.g. by a call to `get`)?

                            Note:
                            If `fork` is to start computation immediately, it must be doing so
                            using some globally accessible resource (such as a thread pool)

                            Alternatively, `fork` can just 'mark' an unevaluated `Par` for concurrent
                            evaluation, which seems a nicer choice than requiring existence of some
                            global resource.

                            (there is more to say on this if needed)
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            `Par` is not a _container_ that we can `get` a value from

                            `Par` is more like a _description_ of a parallel computation

                            Note:
                            `Par` is now a data structure describing a computation, not just a container
                            that we can extract values from when required
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            To make it clear that a `Par` is basically a program that can be run,
                            let's rename `get`:

                            ```scala
                            def run[A](a: Par[A]): A
                            ```

                            `Par` is now a pure data structure, and `run` has to have some means of
                            implementing the parallelism...

                            Note:
                            Our initial API has changed quite a bit, and that's a good thing!

                            We're making progress and learning about deficiencies in our initial design
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Choosing a representation
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Let's review our updated API for `Par`:
                            ```scala
                            // Create a computation that returns immediately
                            def unit[A](a: A): Par[A]

                            // Combine the results of two parallel computations
                            def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C]

                            // Mark a computation to be executed for concurrent evaluation
                            def fork[A](a: => Par[A]): Par[A]

                            // Fully evaluate a given Par, spawing parallel computations
                            // as requested by fork
                            def run[A](a: Par[A]): A
                            ```

                            Note:
                            So far we've just been assuming that `run` has some way of implementing
                            parallelism. Let's dig into that a bit more...
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Can `run` implement parallelism using a `java.util.ExecutorService`?

                            ```scala
                            class ExecutorService {
                                def submit[A](a: Callable[A]): Future[A]
                            }

                            trait Callable[A] { def call: A } // just a lazy A

                            trait Future[A] {
                                def get: A
                                def get(timeout: Long, unit: TimeUnit): A
                                def cancel(evenIfRunning: Boolean): Boolean
                                def isDone: Boolean
                                def isCancelled: Boolean
                            }
                            ```

                            Note:
                            This is the Java API transcribed to Scala.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            For now, let's assume an `ExecutorService` is appropriate:

                            ```scala
                            def run[A](s: ExecutorService)(a: Par[A]): A
                            ```
                            Now, if we define `Par[A]` to be:
                            ```scala
                            type Par[A] = ExecutorService => Future[A]
                            ```
                            Then `run` becomes trivial to implement:
                            ```scala
                            def run[A](s: ExecutorService)(a: Par[A]): Future[A] = a(s)
                            ```

                            Note:
                            By having `Par[A]` defined this way, we give the caller the ability to
                            choose how long to wait for a computation or whether to cancel it etc.

                            `Par` is a function that needs an `ExecutorService`, so the creation
                            of the `Future` doesn't happen until it's provided.
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Refining our API
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Before we move on, let's look at what is possible with the API we have so far.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                            object Par {
                              type Par[A] = ExecutorService => Future[A]

                              def run[A](s: ExecutorService)(a: Par[A]): Future[A] = a(s)

                              def unit[A](a: A): Par[A] = (es: ExecutorService) => UnitFuture(a)

                              // This implementation of `map2` does _not_ respect timeouts
                              def map2[A,B,C](a: Par[A], b: Par[B])(f: (A,B) => C): Par[C] =
                                (es: ExecutorService) => {
                                  val af = a(es)
                                  val bf = b(es)
                                  UnitFuture(f(af.get, bf.get))
                                }

                              // ...
                            ```

                            Note:
                            - `UnitFuture` just wraps a constant value
                            - `map2` doesn't evaluate `f` in a separate logical thread, caller can
                              wrap it in `fork` if they want that
                            - To support timeouts in `map2`, we'd need a new implementation of `Future`
                              that keeps track of the amount of time spend evaluating `af`
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                              def map[A,B](pa: Par[A])(f: A => B): Par[B] =
                                map2(pa, unit(()))((a,_) => f(a))

                              def sortPar(parList: Par[List[Int]]) = map(parList)(_.sorted)

                              def fork[A](a: => Par[A]): Par[A] =
                                es => es.submit(new Callable[A] {
                                  def call = a(es).get
                                })

                              def equal[A](e: ExecutorService)(p: Par[A], p2: Par[A]): Boolean =
                                p(e).get == p2(e).get

                              // ...
                            ```

                            Note:
                            - `map` can lift any function with type `A => B` to operate over a `Par`
                            - This implementation of `fork` is simple, but has some problems
                                - The callable we pass to `es.submit` will block waiting for the
                                  `get` to complete - so we're using two threads
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                            def sequence[A](ps: List[Par[A]]): Par[List[A]] =
                              sys.error("Do your homework!")

                            def parMap[A,B](ps: List[A])(f: A => B): Par[List[B]] = fork {
                              val fbs: List[Par[B]] = ps.map(asyncF(f))
                              sequence(fbs)
                            }
                            ```

                            Note:
                            We're wrapping the body of `parMap` in a `fork` - it will always return
                            immediately, and when we call `run` later it will spawn a computation
                            which itself spawns `N` computations
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Laws for our API

                            Note:
                            Time to step back from blindly following the types and formalize
                            the laws that we expect to hold
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### The law of mapping

                            A concrete example:
                            ```scala
                            map(unit(1))(_ + 1) == unit(2)
                            ```

                            or more generally:

                            ```scala
                            map(unit(x))(f) == unit(f(x))
                            ```

                            and when `f` is `id`:

                            ```scala
                            map(unit(x))(id) == unit(id(x))
                            map(unit(x))(id) == unit(x)
                            map(   y   )(id) == y
                            ```

                            Note:
                            Here we are saying this should hold for _any_ choice of `f` and `x`, which places
                            some useful constraints:

                            - Our implementation of `unit` can't inspect the provided values and
                              behave differently depending on input
                                - So no downcasting or `isInstanceOf` checks

                            Given these constraints, we can reason about what happens when
                            `f` is `id`, which leads us to a simpler law that doesn't mention
                            `unit` at all.

                            Laws like these are very handy when reasoning about your code
                            and when testing it using property based testing, as we will see
                            in the enxt chapter.

                            Mention parametricity?
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### The law of forking

                            `fork` should not affect the result of a parallel computation:

                            ```scala
                            fork(x) == x
                            ```

                            This places strong constraints on our implementation.

                            Note:
                            We’re expecting that `fork(x) == x` for all choices of `x`, and
                            any choice of ExecutorService.

                            Some ExecutorServices are backed by a fixed size thread pool...
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            #### A subtle bug

                            ```scala
                            val a = lazyUnit(42 + 1)
                            val S = Executors.newFixedThreadPool(1)
                            println(Par.equal(S)(a, fork(a)))
                            ```

                            Note:
                            Remember earlier, the issue with our implementation of `fork`?

                            We’re submitting the Callable first, and within that Callable,
                            we’re submitting another Callable to the ExecutorService and
                            blocking on its result

                            There is no way to fix this - we need a different representation
                            for `Par`.
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Fully non-blocking implementation using Actors
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            Homework time!
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Refining combinators to their most general form

                            Note:
                            Functional design is an iterative process, when using an API
                            you might find some new combinator that you need.

                            Sometimes this combinator is just a special form of a more
                            general combinator.
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Choosing between computations

                            Given a computation, use it to choose another:

                            ```scala
                            def choice[A](cond: Par[Boolean])(t: Par[A], f: Par[A]): Par[A]
                            ```

                            We can make this more general by allowing `n` alternatives:

                            ```scala
                            def choiceN[A](n: Par[Int])(choices: List[Par[A]]): Par[A]
                            ```

                            But why require a list of alternatives?

                            ```scala
                            def chooser[A,B](pa: Par[A])(choices: A => Par[B]): Par[B]
                            ```

                            Note:
                            Why restrict the caller to just two alternatives?

                            The type signature of `chooser` may look familiar to functions we've
                            seen in the earlier sections...
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            ```scala
                            def chooser[A,B](pa: Par[A])(choices: A => Par[B]): Par[B]
                            def flatMap[A,B](fa:   F[A])(   f   : A =>   F[B]):   F[B]
                            ```

                            Note:
                            As we have seen in most chapters, if we abstract enough we end up
                            with `flatmap` and `sequence` and friends. We've seen `flatMap`
                            specialised for lists and random number generators, but `flatMap`
                            is a very general function that we will look into in more detail
                            later.

                            We could try to take this process of generalistion further, but
                            by now you probably get the point - before implementing a specific
                            combinator, look to see if it's actually a specific case of a more
                            general combinator that could be reused elsewhere.
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Summary

                            So far, we have:

                            - Completed the design of a library for defining parallel and
                              asynchronous computations in a purely functional way
                            - Explored the process of functional design to gain a sense of the
                              challenges and solutions
                            - Explored what it means for an API to form an _algebra_

                            Note:
                            i.e. we've defined a collection of data types and functions and
                            _laws/properties_ that express relationships between these functions.
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Further reading

                            - [Functional Programming in Scala
                              ](https://www.manning.com/books/functional-programming-in-scala)
                              (obviously)
                            - [Parallel and Concurrent Programming in Haskell
                              ](http://chimera.labs.oreilly.com/books/1230000000929/index.html),
                              if you're interested in this domain specifically (it's free online)
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Property based testing</h1>
                        <h3>(Chapter 8)</h3>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## A brief tour of property-based testing

                            Defining a property:

                            ```scala
                            val intList = Gen.listOf(Gen.choose(0,100))

                            val prop =
                                forAll(intList)(ns => ns.reverse.reverse == ns) &&
                                forAll(intList)(ns => ns.headOption == ns.reverse.lastOption)
                            ```

                            Checking a property:

                            ```
                            scala> prop.check
                            + OK, passed 100 tests.
                            ```

                            Note:
                            - These are examples from `ScalaCheck`
                            - Here `intList` is a generator of list of integers
                            - `forAll` creates a property by combining a generator with a predicate
                            - In the case of failure, ScalaCheck will also minimise test cases to
                              the smallest failing case
                        </script>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Choosing data types and functions</h2>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Initial snippets of an API

                            A type for a generator for values of type `A`:

                            ```scala
                            Gen[A]
                            ```

                            A function to create a generator for lists of values of type `A`:
                            ```scala
                            def listOfN[A](n: Int, a: Gen[A]): Gen[List[A]]
                            ```

                            A function to create a property:

                            ```scala
                            def forAll[A](a: Gen[A])(f: A => Boolean): Prop
                            ```

                            Note:
                            - We'll need something for a generator of values of type `A`
                            - As long as `listOf` is told how to generate values to put
                              in the list, it doesn't need to care about the type of elements in
                              the list, so we can make it polymorphic
                            - `listOfN` is told how long to make the list, this way it stays flexible
                            - That last line sneaks in the introduction of the `Prop`
                              type as well - remember we don't need to know about
                              the representation of a type to start using it in
                              this way!
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### API of properties

                            So far our API consists of `forAll`, `&&` and `check`.

                            Simplest respresentation:

                            ```scala
                            trait Prop { def check: Boolean }
                            ```

                            Better representation:

                            ```scala
                            object Prop {
                                type FailedCase = String
                                type SuccessCount = Int
                            }

                            trait Prop { def check: Either[FailedCase,SuccessCount] }
                            ```

                            Note:
                            - So we can create, `Prop`s, combine them and `check` them
                            - ...
                            - We haven't considered the arguments to `check` yet - let's take a look at generators first
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### API of generators

                            What if we just wrap a state transition and randomly generate values?

                            ```scala
                            case class Gen[A](sample: State[RNG,A])
                            ```

                            Note:
                            - We could just make Gen a type that wraps a State transition over a random number generator:
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            #### Generators that depend on generated values

                            How could we make a `Gen[(String,String)]` where the second string contains only
                            characters from the first?


                            ```scala
                            def flatMap[B](f: A => Gen[B]): Gen[B]
                            ```
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ### Refining the Prop data type

                            We can't just continue checking a `Prop` indefinitely - we need to be told
                            when to stop!

                            ```scala
                            type TestCases = Int
                            type Result = Option[(FailedCase, SuccessCount)]
                            case class Prop(run: TestCases => Result)
                            ```

                            Note:
                            Here we're using an `Option`/`Maybe` for a result, where `None` is success,
                            which is a litle confusing. The book goes on to add a more explicit
                            `Result` type
                        </script>
                    </section>
                    <section data-markdown>
                        <script type="text/template">
                            `Prop.run` will also require a `RNG` to sample from the `Gen`, so we'll
                            add that:
                            ```scala
                            case class Prop(run: (TestCases,RNG) => Result)
                            ```
                        </script>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            # FIN
                            Talk and slides by [Matt Newman](http://mdjnewman.me) ([@mdjnewman](https://twitter.com/mdjnewman))

                            </br>

                            [Buy the book](https://www.manning.com/books/functional-programming-in-scala)
                            and look at the [exercises and source code](https://github.com/fpinscala/fpinscala)

                            Slides: http://mdjnewman.github.io/talk-fp-in-scala-7-8/

                            <small>Also, check out <a href="https://twitter.com/SICPQuotes">@SICPQuotes</a></small>
                        </script>
                    </section>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-37054299-3', 'auto');
          ga('send', 'pageview');
        </script>

    </body>
</html>
